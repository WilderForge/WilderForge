plugins {
    id 'java-library'
    id 'maven-publish'
    id 'eclipse'
}

version = wilderForgeVersion
group = "com.wildermods"
archivesBaseName = "wilderforge"

apply plugin: 'com.wildermods.workspace'

repositories {
    mavenLocal()
    mavenCentral()
    maven {
        url "https://maven.fabricmc.net/"
    }
    maven {
        url "https://maven.wildermods.com/"
    }
}

sourceCompatibility = '17'
targetCompatibility = '17'

dependencies {

	implementation libs.reflections8
	implementation libs.commons.lang
	
	/**********
	don't alter the dependencies below
	***********/
	
	//Wildermyth, Scratchpad
	compileOnly fileTree(dir: './bin/', include: ['*.jar'])
	
	//All dependencies of Wildermyth itself
	compileOnly fileTree(dir: './bin/lib/', include: ['*.jar'])
}

import org.apache.tools.ant.filters.ReplaceTokens

// Define file extensions for token replacement
def tokenReplaceExtensions = ['.java', '.json']

task replaceTokensInResources(type: Sync) {
    from(sourceSets.main.resources.srcDirs) {
        // Only include files matching the defined extensions
        include { file -> tokenReplaceExtensions.any { file.name.endsWith(it) } }
        // Apply token replacement
        filter(ReplaceTokens, tokens: [
            wilderForgeVersion: project.version
        ])
    }
    from(sourceSets.main.resources.srcDirs) {
        // Ensure non-text files are passed through untouched
        exclude { file -> tokenReplaceExtensions.any { file.name.endsWith(it) } }
    }
    into("$buildDir/processedResources")
}

task replaceTokensInSource(type: Sync) {
    doFirst {
        project.logger.lifecycle("Starting file iteration in source files")
        project.logger.lifecycle("Source directories being used: ${sourceSets.main.java.srcDirs}")
    }

    from(sourceSets.main.java.srcDirs) {
        include '**/*'

        eachFile { file ->
            def matchesExtension = tokenReplaceExtensions.any { file.name.endsWith(it) }
        }

        filter(ReplaceTokens, tokens: [
            wilderForgeVersion: project.version
        ])
    }

    into("$buildDir/processedSrc")

    doLast {
        project.logger.lifecycle("File iteration and token replacement complete")
    }
}


sourceSets {
    main {
    	resources.srcDirs = ["$buildDir/processedResources"]
        java.srcDirs = ["$buildDir/processedSrc"]
    }
}

processResources {
    dependsOn replaceTokensInResources
}

compileJava {
    dependsOn replaceTokensInSource
}

task sourceJar(type: Jar) {
    from sourceSets.main.allSource
    archiveClassifier.set('sources')
    destinationDirectory.set(file("$buildDir/libs"))
    dependsOn replaceTokensInSource, replaceTokensInResources
}
build.dependsOn(sourceJar)

ext.mavenLocalUrl = repositories.mavenLocal().url.toString()

tasks.register('checkArtifactExists') {
    doLast {
    
    	if (project.hasProperty('force')) {
			logger.lifecycle("Skipping artifact existence check due to --force flag.")
			return
		}
		
        def repoUrl = project.hasProperty('mavenRepoUrl') ? project.mavenRepoUrl : mavenLocalUrl
        def artifactPath = "${repoUrl}/${project.group.replace('.', '/')}/${project.archivesBaseName}/${project.version}/${project.archivesBaseName}-${project.version}.jar"
        logger.lifecycle("Checking if artifact exists at: $artifactPath")
        
        if (artifactPath.startsWith('file:/')) {
            // Handle file URLs
            def file = new File(new URI(artifactPath))
            if (file.exists()) {
                throw new IllegalStateException("Artifact '${project.group}:${project.archivesBaseName}:${project.version}' already exists. Publishing aborted.")
            }
        } else {
            // Handle HTTP URLs
            def url = new URL(artifactPath)
            def connection = url.openConnection()
            connection.setRequestMethod('HEAD')
            if (connection.responseCode == 200) {
				throw new IllegalStateException("Artifact '${project.group}:${project.archivesBaseName}:${project.version}' already exists. Publishing aborted.")
            }
        }
        logger.lifecycle("Artifact does not exist, proceeding with publish.")
    }
}

tasks.named('publish') {
    dependsOn 'checkArtifactExists'
}

publishing {
    publications {
        mavenJava(MavenPublication) {
            from components.java
            groupId = project.group
            artifactId = project.archivesBaseName
            version = project.version

            // Attach sources JAR to the publication
            artifact sourceJar
        }
    }

    repositories {
        maven {
            url = uri(project.hasProperty('mavenRepoUrl') ? project.mavenRepoUrl : mavenLocalUrl) // Default to mavenLocal if no custom URL is provided
        }
    }
}
